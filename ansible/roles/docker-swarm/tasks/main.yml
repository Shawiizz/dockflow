---
# Docker Swarm role - handles Docker Swarm stack deployment
# 
# Architecture:
# - This role runs ONLY on the manager node
# - Workers have already joined via 'dockflow setup swarm'
# - Images are pre-distributed to all nodes before this role runs
# - docker stack deploy is executed here, Swarm distributes workloads

# Ensure Swarm is active (init if needed for single-node)
- name: Import swarm-cluster role
  import_role:
    name: swarm-cluster

- name: Set stack deployment variables
  set_fact:
    swarm_stack_name: "{{ stack_name }}"
    stacks_dir: "{{ dockflow_paths.stacks | default('/var/lib/dockflow/stacks') }}/{{ stack_name }}"
    use_registry_auth: "{{ config.registry.enabled | default(false) | bool }}"
    resolve_image_flag: "{{ '--resolve-image=never' if not (config.registry.enabled | default(false) | bool) else '' }}"

- name: Ensure stack directories exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /var/lib/dockflow/stacks
    - "{{ stacks_dir }}"

- name: Set release directory based on version
  set_fact:
    release_dir: "{{ stacks_dir }}/{{ version }}"

- name: Check if this version already exists
  stat:
    path: "{{ release_dir }}"
  register: version_dir_exists

- name: Create release directory
  file:
    path: "{{ release_dir }}"
    state: directory
    mode: '0755'

# Create external networks and volumes before deployment
- name: Create external resources for app
  include_tasks: ../../playbooks/create_external_resources.yml
  vars:
    compose_file_path: "{{ root_path }}/.dockflow/docker/docker-compose.yml"
    resource_label: "app"

- name: Transfer docker-compose.yml to release directory
  copy:
    src: "{{ root_path }}/.dockflow/docker/docker-compose.yml"
    dest: "{{ release_dir }}/docker-compose.yml"
    mode: '0644'
  register: compose_transfer

- name: Create release metadata file
  copy:
    content: |
      {
        "project_name": "{{ project_name }}",
        "stack_name": "{{ swarm_stack_name }}",
        "environment": "{{ env }}",
        "version": "{{ version }}",
        "branch": "{{ sanitized_branch_name }}",
        "timestamp": "{{ ansible_date_time.iso8601 }}"
      }
    dest: "{{ release_dir }}/metadata.json"
    mode: '0644'

- name: Update current symlink
  file:
    src: "{{ release_dir }}"
    dest: "{{ stacks_dir }}/current"
    state: link
    force: yes

- name: Login to registry on remote server if configured
  include_tasks: ../../playbooks/docker_registry_login.yml
  vars:
    registry_config: "{{ config.registry | default({}) }}"
  when:
    - config.registry is defined
    - config.registry.enabled | default(false) | bool

- name: Inject Swarm deployment configuration
  block:
    - name: Read current docker-compose.yml
      slurp:
        src: "{{ release_dir }}/docker-compose.yml"
      register: compose_content

    - name: Inject deploy config with defaults
      include_tasks: ../../playbooks/inject_deploy_config.yml
      vars:
        compose_content_b64: "{{ compose_content.content }}"
        inject_mode: "app"

    - name: Write updated docker-compose.yml with deploy config
      copy:
        content: "{{ injected_compose }}"
        dest: "{{ release_dir }}/docker-compose.yml"
        mode: '0644'

- name: Check for stuck rollback state before deployment
  block:
    - name: Get current service states
      shell: |
        docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" 2>/dev/null || echo ""
      register: existing_services
      changed_when: false
      failed_when: false

    - name: Check for rollback_paused or stuck states
      shell: |
        STUCK_SERVICES=""
        for SERVICE in {{ existing_services.stdout_lines | default([]) | join(' ') }}; do
          UPDATE_STATE=$(docker service inspect $SERVICE --format "{{ '{{' }}.UpdateStatus.State{{ '}}' }}" 2>/dev/null || echo "")
          if [ "$UPDATE_STATE" = "rollback_paused" ] || [ "$UPDATE_STATE" = "paused" ]; then
            STUCK_SERVICES="$STUCK_SERVICES $SERVICE"
            echo "Service $SERVICE is stuck in state: $UPDATE_STATE"
          fi
        done
        
        if [ -n "$STUCK_SERVICES" ]; then
          echo "STUCK_SERVICES_FOUND"
          exit 1
        fi
        exit 0
      register: stuck_check
      when: existing_services.stdout | trim | length > 0
      changed_when: false
      failed_when: false

    - name: Remove stuck stack to allow clean redeployment
      shell: |
        echo "Stack has services stuck in rollback_paused state. Removing stack for clean redeployment..."
        docker stack rm {{ swarm_stack_name }}
        
        # Wait for stack to be fully removed
        TIMEOUT=60
        ELAPSED=0
        while [ $ELAPSED -lt $TIMEOUT ]; do
          REMAINING=$(docker stack services {{ swarm_stack_name }} 2>&1 | grep -v "Nothing found" | wc -l)
          if [ "$REMAINING" -eq 0 ]; then
            echo "Stack removed successfully"
            break
          fi
          echo "Waiting for stack removal... ($REMAINING services remaining)"
          sleep 2
          ELAPSED=$((ELAPSED + 2))
        done
        
        # Also cleanup any orphaned containers
        docker container prune -f 2>/dev/null || true
        
        sleep 3
        echo "Ready for clean deployment"
      when: 
        - stuck_check is defined
        - stuck_check.rc is defined
        - stuck_check.rc != 0
      changed_when: true

- name: Deploy Docker stack
  shell: |
    cd {{ release_dir }}
    
    # Build the deploy command
    DEPLOY_CMD="docker stack deploy --compose-file docker-compose.yml"
    {% if config.swarm.prune_services | default(true) | bool %}
    DEPLOY_CMD="$DEPLOY_CMD --prune"
    {% endif %}
    {% if use_registry_auth %}
    DEPLOY_CMD="$DEPLOY_CMD --with-registry-auth"
    {% endif %}
    {% if resolve_image_flag %}
    DEPLOY_CMD="$DEPLOY_CMD {{ resolve_image_flag }}"
    {% endif %}
    DEPLOY_CMD="$DEPLOY_CMD {{ swarm_stack_name }}"
    
    # Execute the deploy command and capture output
    echo "Running: $DEPLOY_CMD"
    DEPLOY_OUTPUT=$($DEPLOY_CMD 2>&1)
    DEPLOY_EXIT_CODE=$?
    echo "$DEPLOY_OUTPUT"
    
    # Check for known error patterns in output even if exit code is 0
    if echo "$DEPLOY_OUTPUT" | grep -q "could not be found"; then
      echo "ERROR: Stack deployment failed - resource not found"
      exit 1
    fi
    
    if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
      echo "ERROR: docker stack deploy failed with exit code $DEPLOY_EXIT_CODE"
      exit $DEPLOY_EXIT_CODE
    fi
    
    echo "Stack {{ swarm_stack_name }} deployed"
  register: stack_deploy
  changed_when: true

- name: Verify stack was created successfully
  shell: |
    # Wait a moment for stack to register
    sleep 2
    
    # Check if stack exists
    if ! docker stack ls --format "{{ '{{' }}.Name{{ '}}' }}" | grep -q "^{{ swarm_stack_name }}$"; then
      echo "ERROR: Stack {{ swarm_stack_name }} was not created!"
      echo "The docker stack deploy command may have failed silently."
      echo ""
      echo "Common causes:"
      echo "  - External network not found (check 'docker network ls')"
      echo "  - Invalid compose file syntax"
      echo "  - Image not found"
      echo ""
      echo "To debug, run on the server:"
      echo "  cd {{ release_dir }}"
      echo "  docker stack deploy --compose-file docker-compose.yml {{ swarm_stack_name }}"
      exit 1
    fi
    
    # Check if services were created
    SERVICE_COUNT=$(docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" | wc -l)
    if [ "$SERVICE_COUNT" -eq 0 ]; then
      echo "ERROR: Stack {{ swarm_stack_name }} exists but has no services!"
      exit 1
    fi
    
    echo "Stack {{ swarm_stack_name }} verified with $SERVICE_COUNT service(s)"
  register: stack_verify
  changed_when: false

- name: Wait for services to converge
  include_tasks: ../../playbooks/wait_for_convergence.yml
  vars:
    convergence_stack_name: "{{ swarm_stack_name }}"
    convergence_timeout: "{{ config.swarm.wait_timeout | default(dockflow_defaults.convergence_timeout) }}"
    convergence_context: "deployment"
  when: config.swarm.wait_for_services | default(true) | bool

- name: Display stack status
  shell: |
    echo "=== Stack Services ==="
    docker stack services {{ swarm_stack_name }}
    echo ""
    echo "=== Stack Tasks ==="
    docker stack ps {{ swarm_stack_name }} --no-trunc 2>/dev/null | head -20
  register: stack_status
  changed_when: false

- name: Show stack deployment status
  debug:
    msg: "{{ stack_status.stdout_lines }}"

- name: Store current release info for external reference
  set_fact:
    current_release_path: "{{ release_dir }}"
    current_version: "{{ version }}"
    current_stack_name: "{{ swarm_stack_name }}"
    current_stacks_dir: "{{ stacks_dir }}"
