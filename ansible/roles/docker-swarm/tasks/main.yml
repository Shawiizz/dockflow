---
# Docker Swarm role - handles Docker Swarm stack deployment
# 
# Architecture:
# - This role runs ONLY on the manager node
# - Workers have already joined via 'dockflow setup swarm'
# - Images are pre-distributed to all nodes before this role runs
# - docker stack deploy is executed here, Swarm distributes workloads

# Ensure Swarm is active (init if needed for single-node)
- name: Import swarm-cluster role
  import_role:
    name: swarm-cluster

- name: Set stack deployment variables
  set_fact:
    swarm_stack_name: "{{ stack_name }}"
    stacks_dir: "/var/lib/dockflow/stacks/{{ stack_name }}"
    use_registry_auth: "{{ config.registry.enabled | default(false) | bool }}"
    resolve_image_flag: "{{ '--resolve-image=never' if not (config.registry.enabled | default(false) | bool) else '' }}"

- name: Ensure stack directories exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /var/lib/dockflow/stacks
    - "{{ stacks_dir }}"

- name: Set release directory based on version
  set_fact:
    release_dir: "{{ stacks_dir }}/{{ version }}"

- name: Check if this version already exists
  stat:
    path: "{{ release_dir }}"
  register: version_dir_exists

- name: Create release directory
  file:
    path: "{{ release_dir }}"
    state: directory
    mode: '0755'

# Create external networks and volumes before deployment
- name: Create external resources for app
  include_tasks: ../../playbooks/create_external_resources.yml
  vars:
    compose_file_path: "{{ root_path }}/.deployment/docker/docker-compose.yml"
    resource_label: "app"

- name: Transfer docker-compose.yml to release directory
  copy:
    src: "{{ root_path }}/.deployment/docker/docker-compose.yml"
    dest: "{{ release_dir }}/docker-compose.yml"
    mode: '0644'
  register: compose_transfer

- name: Create release metadata file
  copy:
    content: |
      {
        "project_name": "{{ project_name }}",
        "stack_name": "{{ swarm_stack_name }}",
        "environment": "{{ env }}",
        "version": "{{ version }}",
        "branch": "{{ sanitized_branch_name }}",
        "timestamp": "{{ ansible_date_time.iso8601 }}"
      }
    dest: "{{ release_dir }}/metadata.json"
    mode: '0644'

- name: Update current symlink
  file:
    src: "{{ release_dir }}"
    dest: "{{ stacks_dir }}/current"
    state: link
    force: yes

- name: Login to registry on remote server if configured
  shell: |
    echo "{{ config.registry.password | default(config.registry.token) }}" | \
    docker login {{ config.registry.url }} \
      --username "{{ config.registry.username | default('oauth2') }}" \
      --password-stdin
  when:
    - config.registry is defined
    - config.registry.enabled | default(false) | bool
    - config.registry.url is defined
  no_log: true
  register: swarm_registry_login

- name: Inject Swarm deployment configuration (defaults only if not set by user)
  block:
    - name: Read current docker-compose.yml
      slurp:
        src: "{{ release_dir }}/docker-compose.yml"
      register: compose_content

    - name: Parse docker-compose.yml
      set_fact:
        compose_data: "{{ compose_content.content | b64decode | from_yaml }}"

    # Recommended defaults for zero-downtime deployments
    # These are only applied if the user hasn't defined them
    - name: Define recommended Swarm defaults
      set_fact:
        default_update_config:
          parallelism: 1
          delay: "10s"
          failure_action: "rollback"
          monitor: "30s"
          max_failure_ratio: 0
          order: "start-first"
        default_rollback_config:
          parallelism: 1
          delay: "5s"
          monitor: "15s"
          order: "start-first"

    - name: Merge user config with defaults (user values take precedence)
      set_fact:
        updated_compose: >-
          {%- set ns = namespace(services={}) -%}
          {%- for service_name, service_config in compose_data.services.items() -%}
            {%- set user_deploy = service_config.deploy | default({}) -%}
            {%- set user_update = user_deploy.update_config | default({}) -%}
            {%- set user_rollback = user_deploy.rollback_config | default({}) -%}
            {%- set merged_update = default_update_config | combine(user_update) -%}
            {%- set merged_rollback = default_rollback_config | combine(user_rollback) -%}
            {%- set merged_deploy = user_deploy | combine({
              'update_config': merged_update,
              'rollback_config': merged_rollback
            }) -%}
            {%- set _ = ns.services.update({service_name: service_config | combine({'deploy': merged_deploy})}) -%}
          {%- endfor -%}
          {{ compose_data | combine({'services': ns.services}) }}

    - name: Write updated docker-compose.yml with deploy config
      copy:
        content: "{{ updated_compose | to_nice_yaml(indent=2, width=999) }}"
        dest: "{{ release_dir }}/docker-compose.yml"
        mode: '0644'

- name: Check for stuck rollback state before deployment
  block:
    - name: Get current service states
      shell: |
        docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" 2>/dev/null || echo ""
      register: existing_services
      changed_when: false
      failed_when: false

    - name: Check for rollback_paused or stuck states
      shell: |
        STUCK_SERVICES=""
        for SERVICE in {{ existing_services.stdout_lines | default([]) | join(' ') }}; do
          UPDATE_STATE=$(docker service inspect $SERVICE --format "{{ '{{' }}.UpdateStatus.State{{ '}}' }}" 2>/dev/null || echo "")
          if [ "$UPDATE_STATE" = "rollback_paused" ] || [ "$UPDATE_STATE" = "paused" ]; then
            STUCK_SERVICES="$STUCK_SERVICES $SERVICE"
            echo "Service $SERVICE is stuck in state: $UPDATE_STATE"
          fi
        done
        
        if [ -n "$STUCK_SERVICES" ]; then
          echo "STUCK_SERVICES_FOUND"
          exit 1
        fi
        exit 0
      register: stuck_check
      when: existing_services.stdout | trim | length > 0
      changed_when: false
      failed_when: false

    - name: Remove stuck stack to allow clean redeployment
      shell: |
        echo "Stack has services stuck in rollback_paused state. Removing stack for clean redeployment..."
        docker stack rm {{ swarm_stack_name }}
        
        # Wait for stack to be fully removed
        TIMEOUT=60
        ELAPSED=0
        while [ $ELAPSED -lt $TIMEOUT ]; do
          REMAINING=$(docker stack services {{ swarm_stack_name }} 2>&1 | grep -v "Nothing found" | wc -l)
          if [ "$REMAINING" -eq 0 ]; then
            echo "Stack removed successfully"
            break
          fi
          echo "Waiting for stack removal... ($REMAINING services remaining)"
          sleep 2
          ELAPSED=$((ELAPSED + 2))
        done
        
        # Also cleanup any orphaned containers
        docker container prune -f 2>/dev/null || true
        
        sleep 3
        echo "Ready for clean deployment"
      when: 
        - stuck_check is defined
        - stuck_check.rc is defined
        - stuck_check.rc != 0
      changed_when: true

- name: Deploy Docker stack
  shell: |
    cd {{ release_dir }}
    
    # Build the deploy command
    DEPLOY_CMD="docker stack deploy --compose-file docker-compose.yml"
    {% if config.swarm.prune_services | default(true) | bool %}
    DEPLOY_CMD="$DEPLOY_CMD --prune"
    {% endif %}
    {% if use_registry_auth %}
    DEPLOY_CMD="$DEPLOY_CMD --with-registry-auth"
    {% endif %}
    {% if resolve_image_flag %}
    DEPLOY_CMD="$DEPLOY_CMD {{ resolve_image_flag }}"
    {% endif %}
    DEPLOY_CMD="$DEPLOY_CMD {{ swarm_stack_name }}"
    
    # Execute the deploy command and capture output
    echo "Running: $DEPLOY_CMD"
    DEPLOY_OUTPUT=$($DEPLOY_CMD 2>&1)
    DEPLOY_EXIT_CODE=$?
    echo "$DEPLOY_OUTPUT"
    
    # Check for known error patterns in output even if exit code is 0
    if echo "$DEPLOY_OUTPUT" | grep -q "could not be found"; then
      echo "ERROR: Stack deployment failed - resource not found"
      exit 1
    fi
    
    if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
      echo "ERROR: docker stack deploy failed with exit code $DEPLOY_EXIT_CODE"
      exit $DEPLOY_EXIT_CODE
    fi
    
    echo "Stack {{ swarm_stack_name }} deployed"
  register: stack_deploy
  changed_when: true

- name: Verify stack was created successfully
  shell: |
    # Wait a moment for stack to register
    sleep 2
    
    # Check if stack exists
    if ! docker stack ls --format "{{ '{{' }}.Name{{ '}}' }}" | grep -q "^{{ swarm_stack_name }}$"; then
      echo "ERROR: Stack {{ swarm_stack_name }} was not created!"
      echo "The docker stack deploy command may have failed silently."
      echo ""
      echo "Common causes:"
      echo "  - External network not found (check 'docker network ls')"
      echo "  - Invalid compose file syntax"
      echo "  - Image not found"
      echo ""
      echo "To debug, run on the server:"
      echo "  cd {{ release_dir }}"
      echo "  docker stack deploy --compose-file docker-compose.yml {{ swarm_stack_name }}"
      exit 1
    fi
    
    # Check if services were created
    SERVICE_COUNT=$(docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" | wc -l)
    if [ "$SERVICE_COUNT" -eq 0 ]; then
      echo "ERROR: Stack {{ swarm_stack_name }} exists but has no services!"
      exit 1
    fi
    
    echo "Stack {{ swarm_stack_name }} verified with $SERVICE_COUNT service(s)"
  register: stack_verify
  changed_when: false

- name: Wait for services to converge
  shell: |
    TIMEOUT={{ config.swarm.wait_timeout | default(300) }}
    ELAPSED=0
    INTERVAL=5
    
    echo "Waiting for services to converge (timeout: ${TIMEOUT}s)..."
    
    while [ $ELAPSED -lt $TIMEOUT ]; do
      # Get service states
      SERVICES=$(docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}:{{ '{{' }}.Replicas{{ '}}' }}")
      
      if [ -z "$SERVICES" ]; then
        echo "No services found yet, waiting..."
        sleep $INTERVAL
        ELAPSED=$((ELAPSED + INTERVAL))
        continue
      fi
      
      ALL_RUNNING=true
      for SERVICE in $SERVICES; do
        NAME=$(echo $SERVICE | cut -d: -f1)
        REPLICAS=$(echo $SERVICE | cut -d: -f2)
        CURRENT=$(echo $REPLICAS | cut -d/ -f1)
        DESIRED=$(echo $REPLICAS | cut -d/ -f2)
        
        if [ "$CURRENT" != "$DESIRED" ]; then
          ALL_RUNNING=false
          echo "Service $NAME: $CURRENT/$DESIRED replicas"
        fi
      done
      
      if [ "$ALL_RUNNING" = "true" ]; then
        echo "All services converged successfully"
        exit 0
      fi
      
      sleep $INTERVAL
      ELAPSED=$((ELAPSED + INTERVAL))
    done
    
    echo "Warning: Timeout reached, some services may not be fully running"
    exit 1
  when: config.swarm.wait_for_services | default(true) | bool
  register: wait_result
  failed_when: false
  changed_when: false

- name: Display stack status
  shell: |
    echo "=== Stack Services ==="
    docker stack services {{ swarm_stack_name }}
    echo ""
    echo "=== Stack Tasks ==="
    docker stack ps {{ swarm_stack_name }} --no-trunc 2>/dev/null | head -20
  register: stack_status
  changed_when: false

- name: Show stack deployment status
  debug:
    msg: "{{ stack_status.stdout_lines }}"

- name: Store current release info for external reference
  set_fact:
    current_release_path: "{{ release_dir }}"
    current_version: "{{ version }}"
    current_stack_name: "{{ swarm_stack_name }}"
    current_stacks_dir: "{{ stacks_dir }}"
