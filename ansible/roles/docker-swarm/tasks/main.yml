---
# Docker Swarm role - handles Docker Swarm stack deployment
# 
# Architecture:
# - This role runs ONLY on the manager node
# - Workers have already joined via 'dockflow setup swarm'
# - Images are pre-distributed to all nodes before this role runs
# - docker stack deploy is executed here, Swarm distributes workloads

# Ensure Swarm is active (init if needed for single-node)
- name: Import swarm-cluster role
  import_role:
    name: swarm-cluster

- name: Set stack deployment variables
  set_fact:
    swarm_stack_name: "{{ stack_name }}"
    stacks_dir: "/var/lib/dockflow/stacks/{{ stack_name }}"
    use_registry_auth: "{{ deployment_config.registry.enabled | default(false) | bool }}"
    resolve_image_flag: "{{ '--resolve-image=never' if not (deployment_config.registry.enabled | default(false) | bool) else '' }}"

- name: Ensure stack directories exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /var/lib/dockflow/stacks
    - "{{ stacks_dir }}"

- name: Set release directory based on version
  set_fact:
    release_dir: "{{ stacks_dir }}/{{ version }}"

- name: Check if this version already exists
  stat:
    path: "{{ release_dir }}"
  register: version_dir_exists

- name: Create release directory
  file:
    path: "{{ release_dir }}"
    state: directory
    mode: '0755'

- name: Generate rendered docker-compose using decomposerize
  shell: |
    cd {{ root_path }}/.deployment/docker
    decomposerize docker-compose.yml --composerize {{ environmentize_option }} --ansible-env-vars-format > /tmp/decomposerize_compose.j2
  delegate_to: localhost
  changed_when: false

- name: Render docker-compose template with variables
  template:
    src: /tmp/decomposerize_compose.j2
    dest: /tmp/decomposerize_compose_rendered.yml
  delegate_to: localhost
  changed_when: false

- name: Transfer rendered docker-compose.yml to release directory
  copy:
    src: /tmp/decomposerize_compose_rendered.yml
    dest: "{{ release_dir }}/docker-compose.yml"
    mode: '0644'
  register: compose_transfer

- name: Create release metadata file
  copy:
    content: |
      {
        "project_name": "{{ project_name }}",
        "stack_name": "{{ swarm_stack_name }}",
        "environment": "{{ env }}",
        "version": "{{ version }}",
        "branch": "{{ sanitized_branch_name }}",
        "timestamp": "{{ ansible_date_time.iso8601 }}"
      }
    dest: "{{ release_dir }}/metadata.json"
    mode: '0644'

- name: Update current symlink
  file:
    src: "{{ release_dir }}"
    dest: "{{ stacks_dir }}/current"
    state: link
    force: yes

- name: Login to registry on remote server if configured
  shell: |
    echo "{{ deployment_config.registry.password | default(deployment_config.registry.token) }}" | \
    docker login {{ deployment_config.registry.url }} \
      --username "{{ deployment_config.registry.username | default('oauth2') }}" \
      --password-stdin
  when:
    - deployment_config.registry is defined
    - deployment_config.registry.enabled | default(false) | bool
    - deployment_config.registry.url is defined
  no_log: true
  register: swarm_registry_login

- name: Inject Swarm deployment configuration
  block:
    - name: Read current docker-compose.yml
      slurp:
        src: "{{ release_dir }}/docker-compose.yml"
      register: compose_content

    - name: Parse docker-compose.yml
      set_fact:
        compose_data: "{{ compose_content.content | b64decode | from_yaml }}"

    - name: Inject default deploy config for services
      set_fact:
        updated_compose: >-
          {%- set ns = namespace(services={}) -%}
          {%- for service_name, service_config in compose_data.services.items() -%}
            {%- set deploy_config = service_config.deploy | default({}) -%}
            {%- set update_config = deploy_config.update_config | default({}) -%}
            {%- set new_update_config = {
              'parallelism': update_config.parallelism | default(1),
              'delay': update_config.delay | default('10s'),
              'failure_action': update_config.failure_action | default('rollback'),
              'monitor': update_config.monitor | default('30s'),
              'max_failure_ratio': update_config.max_failure_ratio | default(0),
              'order': update_config.order | default('start-first')
            } -%}
            {%- set new_deploy = deploy_config | combine({'update_config': new_update_config}) -%}
            {%- set _ = ns.services.update({service_name: service_config | combine({'deploy': new_deploy})}) -%}
          {%- endfor -%}
          {{ compose_data | combine({'services': ns.services}) }}

    - name: Write updated docker-compose.yml with deploy config
      copy:
        content: "{{ updated_compose | to_nice_yaml(indent=2, width=999) }}"
        dest: "{{ release_dir }}/docker-compose.yml"
        mode: '0644'

- name: Check for stuck rollback state before deployment
  block:
    - name: Get current service states
      shell: |
        docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" 2>/dev/null || echo ""
      register: existing_services
      changed_when: false
      failed_when: false

    - name: Check for rollback_paused or stuck states
      shell: |
        STUCK_SERVICES=""
        for SERVICE in {{ existing_services.stdout_lines | default([]) | join(' ') }}; do
          UPDATE_STATE=$(docker service inspect $SERVICE --format "{{ '{{' }}.UpdateStatus.State{{ '}}' }}" 2>/dev/null || echo "")
          if [ "$UPDATE_STATE" = "rollback_paused" ] || [ "$UPDATE_STATE" = "paused" ]; then
            STUCK_SERVICES="$STUCK_SERVICES $SERVICE"
            echo "Service $SERVICE is stuck in state: $UPDATE_STATE"
          fi
        done
        
        if [ -n "$STUCK_SERVICES" ]; then
          echo "STUCK_SERVICES_FOUND"
          exit 1
        fi
        exit 0
      register: stuck_check
      when: existing_services.stdout | trim | length > 0
      changed_when: false
      failed_when: false

    - name: Remove stuck stack to allow clean redeployment
      shell: |
        echo "Stack has services stuck in rollback_paused state. Removing stack for clean redeployment..."
        docker stack rm {{ swarm_stack_name }}
        
        # Wait for stack to be fully removed
        TIMEOUT=60
        ELAPSED=0
        while [ $ELAPSED -lt $TIMEOUT ]; do
          REMAINING=$(docker stack services {{ swarm_stack_name }} 2>&1 | grep -v "Nothing found" | wc -l)
          if [ "$REMAINING" -eq 0 ]; then
            echo "Stack removed successfully"
            break
          fi
          echo "Waiting for stack removal... ($REMAINING services remaining)"
          sleep 2
          ELAPSED=$((ELAPSED + 2))
        done
        
        # Also cleanup any orphaned containers
        docker container prune -f 2>/dev/null || true
        
        sleep 3
        echo "Ready for clean deployment"
      when: 
        - stuck_check is defined
        - stuck_check.rc is defined
        - stuck_check.rc != 0
      changed_when: true

- name: Deploy Docker stack
  shell: |
    cd {{ release_dir }}
    
    # Build the deploy command
    DEPLOY_CMD="docker stack deploy --compose-file docker-compose.yml"
    {% if deployment_config.swarm.prune_services | default(true) | bool %}
    DEPLOY_CMD="$DEPLOY_CMD --prune"
    {% endif %}
    {% if use_registry_auth %}
    DEPLOY_CMD="$DEPLOY_CMD --with-registry-auth"
    {% endif %}
    {% if resolve_image_flag %}
    DEPLOY_CMD="$DEPLOY_CMD {{ resolve_image_flag }}"
    {% endif %}
    DEPLOY_CMD="$DEPLOY_CMD {{ swarm_stack_name }}"
    
    # Execute the deploy command
    echo "Running: $DEPLOY_CMD"
    $DEPLOY_CMD
    
    echo "Stack {{ swarm_stack_name }} deployed"
  register: stack_deploy
  changed_when: true

- name: Wait for services to converge
  shell: |
    TIMEOUT={{ deployment_config.swarm.wait_timeout | default(300) }}
    ELAPSED=0
    INTERVAL=5
    
    echo "Waiting for services to converge (timeout: ${TIMEOUT}s)..."
    
    while [ $ELAPSED -lt $TIMEOUT ]; do
      # Get service states
      SERVICES=$(docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}:{{ '{{' }}.Replicas{{ '}}' }}")
      
      if [ -z "$SERVICES" ]; then
        echo "No services found yet, waiting..."
        sleep $INTERVAL
        ELAPSED=$((ELAPSED + INTERVAL))
        continue
      fi
      
      ALL_RUNNING=true
      for SERVICE in $SERVICES; do
        NAME=$(echo $SERVICE | cut -d: -f1)
        REPLICAS=$(echo $SERVICE | cut -d: -f2)
        CURRENT=$(echo $REPLICAS | cut -d/ -f1)
        DESIRED=$(echo $REPLICAS | cut -d/ -f2)
        
        if [ "$CURRENT" != "$DESIRED" ]; then
          ALL_RUNNING=false
          echo "Service $NAME: $CURRENT/$DESIRED replicas"
        fi
      done
      
      if [ "$ALL_RUNNING" = "true" ]; then
        echo "All services converged successfully"
        exit 0
      fi
      
      sleep $INTERVAL
      ELAPSED=$((ELAPSED + INTERVAL))
    done
    
    echo "Warning: Timeout reached, some services may not be fully running"
    exit 1
  when: deployment_config.swarm.wait_for_services | default(true) | bool
  register: wait_result
  failed_when: false
  changed_when: false

- name: Display stack status
  shell: |
    echo "=== Stack Services ==="
    docker stack services {{ swarm_stack_name }}
    echo ""
    echo "=== Stack Tasks ==="
    docker stack ps {{ swarm_stack_name }} --no-trunc 2>/dev/null | head -20
  register: stack_status
  changed_when: false

- name: Show stack deployment status
  debug:
    msg: "{{ stack_status.stdout_lines }}"

- name: Store current release info for external reference
  set_fact:
    current_release_path: "{{ release_dir }}"
    current_version: "{{ version }}"
    current_stack_name: "{{ swarm_stack_name }}"
    current_stacks_dir: "{{ stacks_dir }}"
