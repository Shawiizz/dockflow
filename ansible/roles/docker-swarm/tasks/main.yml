---
# Docker Swarm role - handles Docker Swarm stack deployment
# 
# Architecture:
# - This role runs ONLY on the manager node
# - Workers have already joined via 'dockflow setup swarm'
# - Images are pre-distributed to all nodes before this role runs
# - docker stack deploy is executed here, Swarm distributes workloads

# Ensure Swarm is active (init if needed for single-node)
- name: Import swarm-cluster role
  import_role:
    name: swarm-cluster

- name: Set stack deployment variables
  set_fact:
    swarm_stack_name: "{{ stack_name }}"
    use_registry_auth: "{{ config.registry.enabled | default(false) | bool }}"
    resolve_image_flag: "{{ '--resolve-image=never' if not (config.registry.enabled | default(false) | bool) else '' }}"

- name: Ensure stack directory exists
  file:
    path: "{{ stack_dir }}"
    state: directory
    mode: '0755'

- name: Set release directory based on version
  set_fact:
    release_dir: "{{ stack_dir }}/{{ version }}"

- name: Check if this version already exists
  stat:
    path: "{{ release_dir }}"
  register: version_dir_exists

- name: Create release directory
  file:
    path: "{{ release_dir }}"
    state: directory
    mode: '0755'

# Create external networks and volumes before deployment
- name: Create external resources for app
  include_role:
    name: _shared/create-resources
  vars:
    compose_file_path: "{{ compose_path }}"
    resource_label: "app"

- name: Transfer docker-compose.yml to release directory
  copy:
    src: "{{ compose_path }}"
    dest: "{{ release_dir }}/docker-compose.yml"
    mode: '0644'
  register: compose_transfer

- name: Create release metadata file
  copy:
    content: |
      {
        "project_name": "{{ config.project_name }}",
        "stack_name": "{{ swarm_stack_name }}",
        "environment": "{{ env }}",
        "version": "{{ version }}",
        "branch": "{{ sanitized_branch_name }}",
        "timestamp": "{{ ansible_date_time.iso8601 }}"
      }
    dest: "{{ release_dir }}/metadata.json"
    mode: '0644'

- name: Update current symlink
  file:
    src: "{{ release_dir }}"
    dest: "{{ stack_dir }}/current"
    state: link
    force: yes

- name: Login to registry on remote server if configured
  include_role:
    name: _shared/registry-login
  vars:
    registry_config: "{{ config.registry | default({}) }}"
  when:
    - config.registry is defined
    - config.registry.enabled | default(false) | bool

- name: Inject Swarm deployment configuration
  block:
    - name: Read current docker-compose.yml
      slurp:
        src: "{{ release_dir }}/docker-compose.yml"
      register: compose_content

    - name: Inject deploy config with defaults
      include_role:
        name: _shared/inject-deploy
      vars:
        compose_content_b64: "{{ compose_content.content }}"
        inject_mode: "app"

    - name: Write updated docker-compose.yml with deploy config
      copy:
        content: "{{ injected_compose }}"
        dest: "{{ release_dir }}/docker-compose.yml"
        mode: '0644'

- name: Check for stuck rollback state before deployment
  block:
    - name: Get current service states
      shell: |
        docker stack services {{ swarm_stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" 2>/dev/null || echo ""
      register: existing_services
      changed_when: false
      failed_when: false

    - name: Check for rollback_paused or stuck states
      shell: |
        STUCK_SERVICES=""
        for SERVICE in {{ existing_services.stdout_lines | default([]) | join(' ') }}; do
          UPDATE_STATE=$(docker service inspect $SERVICE --format "{{ '{{' }}.UpdateStatus.State{{ '}}' }}" 2>/dev/null || echo "")
          if [ "$UPDATE_STATE" = "rollback_paused" ] || [ "$UPDATE_STATE" = "paused" ]; then
            STUCK_SERVICES="$STUCK_SERVICES $SERVICE"
            echo "Service $SERVICE is stuck in state: $UPDATE_STATE"
          fi
        done
        
        if [ -n "$STUCK_SERVICES" ]; then
          echo "STUCK_SERVICES_FOUND"
          exit 1
        fi
        exit 0
      register: stuck_check
      when: existing_services.stdout | trim | length > 0
      changed_when: false
      failed_when: false

    - name: Remove stuck stack to allow clean redeployment
      community.docker.docker_stack:
        name: "{{ swarm_stack_name }}"
        state: absent
        absent_retries: 10
        absent_retries_interval: 2
      when: 
        - stuck_check is defined
        - stuck_check.rc is defined
        - stuck_check.rc != 0

    - name: Cleanup orphaned containers after stuck stack removal
      community.docker.docker_prune:
        containers: true
      when: 
        - stuck_check is defined
        - stuck_check.rc is defined
        - stuck_check.rc != 0
      failed_when: false

    - name: Wait after stack removal
      pause:
        seconds: 3
      when: 
        - stuck_check is defined
        - stuck_check.rc is defined
        - stuck_check.rc != 0

- name: Deploy Docker stack
  community.docker.docker_stack:
    name: "{{ swarm_stack_name }}"
    state: present
    compose:
      - "{{ release_dir }}/docker-compose.yml"
    prune: "{{ config.swarm.prune_services | default(true) | bool }}"
    with_registry_auth: "{{ use_registry_auth }}"
    resolve_image: "{{ 'never' if not (config.registry.enabled | default(false) | bool) else 'always' }}"
  register: stack_deploy

- name: Display stack deployment result
  debug:
    msg: "Stack {{ swarm_stack_name }} deployed successfully"
  when: stack_deploy is changed

- name: Verify stack services exist
  community.docker.docker_stack_info:
    name: "{{ swarm_stack_name }}"
  register: stack_info

- name: Fail if no services in stack
  fail:
    msg: "Stack {{ swarm_stack_name }} was deployed but has no services!"
  when: stack_info.results | length == 0

- name: Display stack service count
  debug:
    msg: "Stack {{ swarm_stack_name }} verified with {{ stack_info.results | length }} service(s)"

- name: Wait for services to converge
  include_role:
    name: _shared/wait-convergence
  vars:
    convergence_stack_name: "{{ swarm_stack_name }}"
    convergence_timeout: "{{ config.swarm.wait_timeout | default(dockflow_defaults.convergence_timeout) }}"
    convergence_context: "deployment"
  when: config.swarm.wait_for_services | default(true) | bool

- name: Display stack status
  shell: |
    echo "=== Stack Services ==="
    docker stack services {{ swarm_stack_name }}
    echo ""
    echo "=== Stack Tasks ==="
    docker stack ps {{ swarm_stack_name }} --no-trunc 2>/dev/null | head -20
  register: stack_status
  changed_when: false

- name: Show stack deployment status
  debug:
    msg: "{{ stack_status.stdout_lines }}"

- name: Store current release info for external reference
  set_fact:
    current_release_path: "{{ release_dir }}"
    current_version: "{{ version }}"
    current_stack_name: "{{ swarm_stack_name }}"
    current_stacks_dir: "{{ stack_dir }}"
