---
# Stack management role - handles stack retention and cleanup
# This task cleans up old releases while keeping the configured number

- name: Get configuration for number of releases to keep
  set_fact:
    keep_releases: "{{ config.stack_management.keep_releases | default(3) | int }}"

- name: Find all release directories
  find:
    paths: "{{ stack_dir }}"
    file_type: directory
    excludes: "current"
  register: stack_releases

- name: Read metadata from all releases to get timestamps
  slurp:
    src: "{{ item.path }}/metadata.json"
  register: all_metadata
  loop: "{{ stack_releases.files }}"
  failed_when: false
  loop_control:
    label: "{{ item.path | basename }}"

- name: Sort releases by timestamp and determine which to remove
  set_fact:
    sorted_releases: >-
      {%- set releases_with_timestamp = [] -%}
      {%- for result in all_metadata.results -%}
        {%- if result.content is defined -%}
          {%- set metadata = result.content | b64decode | from_json -%}
          {%- set _ = releases_with_timestamp.append({
            'path': result.item.path,
            'version': metadata.version | default(result.item.path | basename),
            'timestamp': metadata.timestamp | default('1970-01-01T00:00:00Z')
          }) -%}
        {%- else -%}
          {%- set _ = releases_with_timestamp.append({
            'path': result.item.path,
            'version': result.item.path | basename,
            'timestamp': '1970-01-01T00:00:00Z'
          }) -%}
        {%- endif -%}
      {%- endfor -%}
      {{ releases_with_timestamp | sort(attribute='timestamp', reverse=true) }}

- name: Determine releases to keep and remove
  set_fact:
    releases_to_keep: "{{ sorted_releases[:keep_releases | int] }}"
    releases_to_remove: "{{ sorted_releases[keep_releases | int:] }}"

- name: Display stack management plan
  debug:
    msg: |
      Stack Management Configuration:
      - Keep releases: {{ keep_releases }}
      - Total releases: {{ sorted_releases | length }}
      - Releases to keep: {{ releases_to_keep | map(attribute='version') | list }}
      - Releases to remove: {{ releases_to_remove | map(attribute='version') | list }}
  when: not global_no_log | default(false)

- name: Extract images from releases to remove
  block:
    - name: Read metadata from releases to remove
      slurp:
        src: "{{ item.path }}/metadata.json"
      register: removed_metadata
      loop: "{{ releases_to_remove }}"
      failed_when: false
      loop_control:
        label: "{{ item.path | basename }}"

    - name: Read docker-compose from releases to remove
      slurp:
        src: "{{ item.path }}/docker-compose.yml"
      register: removed_compose
      loop: "{{ releases_to_remove }}"
      failed_when: false
      loop_control:
        label: "{{ item.path | basename }}"

    - name: Extract image names from removed releases
      set_fact:
        images_from_removed_releases: >-
          {%- set images = [] -%}
          {%- for result in removed_compose.results -%}
            {%- if result.content is defined -%}
              {%- set compose = result.content | b64decode | from_yaml -%}
              {%- for svc_name, svc_config in compose.services.items() -%}
                {%- if svc_config.image is defined -%}
                  {%- set _ = images.append(svc_config.image) -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ images | unique }}
      when: removed_compose.results is defined

  when: releases_to_remove | length > 0

- name: Build list of protected images from releases to keep
  block:
    - name: Read docker-compose from releases to keep
      slurp:
        src: "{{ item.path }}/docker-compose.yml"
      register: kept_compose
      loop: "{{ releases_to_keep }}"
      failed_when: false
      loop_control:
        label: "{{ item.path | basename }}"

    - name: Extract image names from kept releases
      set_fact:
        protected_images: >-
          {%- set images = [] -%}
          {%- for result in kept_compose.results -%}
            {%- if result.content is defined -%}
              {%- set compose = result.content | b64decode | from_yaml -%}
              {%- for svc_name, svc_config in compose.services.items() -%}
                {%- if svc_config.image is defined -%}
                  {%- set _ = images.append(svc_config.image) -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ images | unique }}
      when: kept_compose.results is defined

- name: Set empty lists if not defined
  set_fact:
    images_from_removed_releases: []
    protected_images: []
  when: images_from_removed_releases is not defined or protected_images is not defined

- name: Get currently running images in Swarm (for rollback safety)
  shell: |
    docker stack services {{ stack_name }} --format "{{ '{{' }}.Image{{ '}}' }}" 2>/dev/null || true
    # Also get images from recent task history (last 5 tasks per service)
    for SERVICE in $(docker stack services {{ stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}" 2>/dev/null); do
      docker service ps $SERVICE --format "{{ '{{' }}.Image{{ '}}' }}" 2>/dev/null | head -5
    done
  register: running_images_raw
  changed_when: false
  failed_when: false

- name: Add running images to protected list
  set_fact:
    protected_images: "{{ (protected_images | default([])) + (running_images_raw.stdout_lines | default([]) | unique) }}"

- name: Determine images to delete
  set_fact:
    images_to_delete: "{{ images_from_removed_releases | default([]) | reject('in', protected_images | default([])) | reject('search', ':latest$') | list }}"

- name: Display cleanup plan
  debug:
    msg: |
      Cleanup Plan:
      - Protected images: {{ protected_images | length }}
      - Images from removed releases: {{ images_from_removed_releases | default([]) | length }}
      - Images to delete: {{ images_to_delete | length }}
      {% if images_to_delete | length > 0 %}
      
      Images to delete:
      {% for image in images_to_delete %}
      - {{ image }}
      {% endfor %}
      {% endif %}
  when: not global_no_log | default(false)

- name: Remove stopped containers from images to delete
  shell: |
    # Find and remove containers that were using the image to delete
    CONTAINERS=$(docker ps -a --filter "ancestor={{ item }}" --format "{{ '{{' }}.ID{{ '}}' }}" 2>/dev/null)
    if [ -n "$CONTAINERS" ]; then
      echo "$CONTAINERS" | xargs -r docker rm -f 2>/dev/null || true
    fi
  loop: "{{ images_to_delete }}"
  when: images_to_delete | length > 0
  failed_when: false
  changed_when: false
  loop_control:
    label: "Cleaning containers for {{ item }}"

- name: Delete old images
  shell: "docker rmi {{ item }} 2>/dev/null || true"
  loop: "{{ images_to_delete }}"
  when: images_to_delete | length > 0
  failed_when: false
  loop_control:
    label: "Removing {{ item }}"

- name: Remove old release directories
  file:
    path: "{{ item.path }}"
    state: absent
  loop: "{{ releases_to_remove }}"
  when: releases_to_remove | length > 0
  loop_control:
    label: "{{ item.path | basename }}"

- name: Display cleanup summary
  debug:
    msg: |
      Cleanup Summary:
      - Removed {{ releases_to_remove | length }} old stack releases
      - Deleted {{ images_to_delete | length }} unused images
      - Kept {{ releases_to_keep | length }} recent releases
  when: not global_no_log | default(false)
