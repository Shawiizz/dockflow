---
# Local build role - builds Docker images locally
# Contexts are accessed directly (via symlinks or overlayfs), Docker CLI handles .dockerignore

- name: Set build paths
  set_fact:
    docker_compose_path: "{{ root_path }}/.dockflow/docker"
    workspace_path: "{{ root_path }}"
  delegate_to: localhost

- name: Generate build commands using decomposerize
  shell: |
    cd {{ docker_compose_path }}
    decomposerize docker-compose.yml --docker-build {{ services_option }}
  delegate_to: localhost
  register: build_commands_output
  changed_when: false

# Parse build commands to extract dockerfile and tag
# decomposerize outputs: docker build -f <dockerfile> -t "<tag>" <context>
- name: Parse build commands
  set_fact:
    build_commands: []
  delegate_to: localhost

- name: Build command list
  set_fact:
    build_commands: "{{ build_commands + [build_info] }}"
  vars:
    context_relative: "{{ item.split()[-1] }}"
    context_resolved: "{{ (docker_compose_path + '/' + context_relative) | realpath }}"
    dockerfile_original: "{{ item | regex_search('-f\\s+([^\\s]+)', '\\1') | first }}"
    dockerfile_absolute: "{{ (docker_compose_path + '/' + dockerfile_original) | realpath }}"
    image_tag: "{{ item | regex_search('-t\\s+\"?([^\"\\s]+)\"?', '\\1') | first }}"
    build_info:
      context: "{{ context_resolved }}"
      dockerfile: "{{ dockerfile_absolute }}"
      tag: "{{ image_tag }}"
  loop: "{{ build_commands_output.stdout_lines | select('truthy') | list }}"
  delegate_to: localhost

- name: Display build commands
  debug:
    msg: "Build {{ item.tag }} from {{ item.context }} using {{ item.dockerfile }}"
  loop: "{{ build_commands }}"
  delegate_to: localhost
  loop_control:
    label: "build command"

- name: Display build information
  debug:
    msg: "Building {{ build_commands | length }} Docker image(s) locally for {{ env }} {{ inventory_hostname }}"
  delegate_to: localhost

# Single image: run without backgrounding for real-time log streaming
- name: Build Docker image (streaming)
  shell: |
    set -e
    echo "Building: {{ build_commands[0].tag }}"

    START_TIME=$(date +%s)
    docker build \
      -f "{{ build_commands[0].dockerfile }}" \
      -t "{{ build_commands[0].tag }}" \
      "{{ build_commands[0].context }}"
    END_TIME=$(date +%s)
    echo ""
    echo "✓ Built {{ build_commands[0].tag }} in $((END_TIME - START_TIME))s"
  delegate_to: localhost
  register: build_results
  when: build_commands is defined and build_commands | length == 1

# Multiple images: parallel builds (output after completion)
- name: Build Docker images locally (parallel)
  shell: |
    set -e
    PIDS=""
    TIMING_FILE=$(mktemp)
    {% for item in build_commands %}
    echo "Starting build: {{ item.tag }}"
    (
      START_TIME=$(date +%s)
      docker build \
        -f "{{ item.dockerfile }}" \
        -t "{{ item.tag }}" \
        "{{ item.context }}"
      END_TIME=$(date +%s)
      DURATION=$((END_TIME - START_TIME))
      echo "{{ item.tag }}|$DURATION" >> "$TIMING_FILE"
      echo "✓ Built {{ item.tag }} in ${DURATION}s"
    ) &
    PIDS="$PIDS $!"
    {% endfor %}
    # Wait for all builds and capture exit codes
    FAILED=0
    for PID in $PIDS; do
      if ! wait $PID; then
        FAILED=1
      fi
    done
    # Display timing summary
    echo ""
    echo "Build times:"
    sort -t'|' -k2 -n "$TIMING_FILE" | while IFS='|' read -r TAG TIME; do
      printf "  %-50s %6.1fs\n" "$TAG" "$TIME"
    done
    rm -f "$TIMING_FILE"
    exit $FAILED
  delegate_to: localhost
  register: build_results
  when: build_commands is defined and build_commands | length > 1

- name: Display build times
  debug:
    msg: "{{ build_results.stdout_lines }}"
  delegate_to: localhost
  when: build_results.stdout_lines is defined and build_results.stdout_lines | length > 0

- name: Display build validation completion
  debug:
    msg: "Successfully validated {{ build_commands | length }} Docker image(s) build"
  delegate_to: localhost
  when: env == 'build'

# Push images to registry if configured (external registry)
- name: Push images to registry
  include_role:
    name: ../roles/docker-registry
  vars:
    built_images: "{{ build_commands | map(attribute='tag') | list }}"
  when:
    - config.registry is defined
    - config.registry.enabled | default(false) | bool
    - not (build_mode | default(false) | bool)

# Use local registry for image transfer when no external registry is configured
- name: Transfer images via local registry
  include_role:
    name: ../roles/local-registry
  vars:
    built_images: "{{ build_commands | map(attribute='tag') | list }}"
  when:
    - not (config.registry.enabled | default(false) | bool)
    - not (build_mode | default(false) | bool)
