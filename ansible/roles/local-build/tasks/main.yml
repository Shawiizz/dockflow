---
# Local build role - builds Docker images locally in CI/CD
# This role runs on localhost (CI/CD runner) before transferring images via local registry

# Note: We use tar with --dereference (-h) to follow symlinks when building
# This allows Docker to receive real files even when /workspace contains symlinks to /project
- name: Set build paths
  set_fact:
    docker_compose_path: "{{ root_path }}/.dockflow/docker"
    workspace_path: "{{ root_path }}"
  delegate_to: localhost

- name: Generate build commands using decomposerize
  shell: |
    cd {{ docker_compose_path }}
    decomposerize docker-compose.yml --docker-build {{ services_option }}
  delegate_to: localhost
  register: build_commands_output
  changed_when: false

# Parse build commands to extract dockerfile and tag, then create tar-based commands
# decomposerize outputs: docker build -f <dockerfile> -t "<tag>" <context>
# We transform to: (tar context + tar Dockerfile) | docker build -f Dockerfile -
- name: Parse and transform build commands for tar streaming
  set_fact:
    build_commands: []
  delegate_to: localhost

- name: Build tar streaming commands
  set_fact:
    build_commands: "{{ build_commands + [build_info] }}"
  vars:
    # Extract the context (last word of the command)
    context_relative: "{{ item.split()[-1] }}"
    # Resolve the context path - use realpath to follow symlinks
    context_resolved: "{{ (docker_compose_path + '/' + context_relative) | realpath }}"
    # Extract dockerfile path (after -f)
    dockerfile_original: "{{ item | regex_search('-f\\s+([^\\s]+)', '\\1') | first }}"
    # Resolve dockerfile path
    dockerfile_absolute: "{{ (docker_compose_path + '/' + dockerfile_original) | realpath }}"
    # Extract image tag
    image_tag: "{{ item | regex_search('-t\\s+\"?([^\"\\s]+)\"?', '\\1') | first }}"
    # Build info dict
    build_info:
      context: "{{ context_resolved }}"
      dockerfile: "{{ dockerfile_absolute }}"
      tag: "{{ image_tag }}"
  loop: "{{ build_commands_output.stdout_lines | select('truthy') | list }}"
  delegate_to: localhost

- name: Display build commands
  debug:
    msg: "Build {{ item.tag }} from {{ item.context }} using {{ item.dockerfile }}"
  loop: "{{ build_commands }}"
  delegate_to: localhost
  loop_control:
    label: "build command"

- name: Display build information
  debug:
    msg: "Building {{ build_commands | length }} Docker image(s) locally for {{ env }} {{ inventory_hostname }}"
  delegate_to: localhost

- name: Build Docker images locally (parallel with tar streaming)
  shell: |
    set -e
    PIDS=""
    TIMING_FILE=$(mktemp)
    {% for item in build_commands %}
    echo "Starting build: {{ item.tag }}"
    (
      START_TIME=$(date +%s)
      # Create staging dir for combined tar archive
      STAGE=$(mktemp -d)
      trap "rm -rf $STAGE" EXIT
      # Copy Dockerfile to staging
      cp "{{ item.dockerfile }}" "$STAGE/Dockerfile"
      # Create combined tar: context files + Dockerfile (using append)
      tar -chf "$STAGE/context.tar" -C "{{ item.context }}" --exclude=.git .
      tar -rf "$STAGE/context.tar" -C "$STAGE" Dockerfile
      # Stream to docker build
      cat "$STAGE/context.tar" | docker build -f Dockerfile -t "{{ item.tag }}" -
      END_TIME=$(date +%s)
      DURATION=$((END_TIME - START_TIME))
      echo "{{ item.tag }}|$DURATION" >> "$TIMING_FILE"
      echo "âœ“ Built {{ item.tag }} in ${DURATION}s"
    ) &
    PIDS="$PIDS $!"
    {% endfor %}
    # Wait for all builds and capture exit codes
    FAILED=0
    for PID in $PIDS; do
      if ! wait $PID; then
        FAILED=1
      fi
    done
    # Display timing summary
    echo ""
    echo "Build times:"
    sort -t'|' -k2 -n "$TIMING_FILE" | while IFS='|' read -r TAG TIME; do
      printf "  %-50s %6.1fs\n" "$TAG" "$TIME"
    done
    rm -f "$TIMING_FILE"
    exit $FAILED
  delegate_to: localhost
  register: build_results
  when: build_commands is defined and build_commands | length > 0

- name: Display build times
  debug:
    msg: "{{ build_results.stdout_lines }}"
  delegate_to: localhost
  when: build_results.stdout_lines is defined and build_results.stdout_lines | length > 0

- name: Display build validation completion
  debug:
    msg: "Successfully validated {{ build_commands | length }} Docker image(s) build"
  delegate_to: localhost
  when: env == 'build'

# Push images to registry if configured (external registry)
- name: Push images to registry
  include_role:
    name: ../roles/docker-registry
  vars:
    built_images: "{{ build_commands | map(attribute='tag') | list }}"
  when:
    - config.registry is defined
    - config.registry.enabled | default(false) | bool
    - not (build_mode | default(false) | bool)

# Use local registry for image transfer when no external registry is configured
- name: Transfer images via local registry
  include_role:
    name: ../roles/local-registry
  vars:
    built_images: "{{ build_commands | map(attribute='tag') | list }}"
  when:
    - not (config.registry.enabled | default(false) | bool)
    - not (build_mode | default(false) | bool)
