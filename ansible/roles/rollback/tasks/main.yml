---
# Rollback role - rolls back to a previous release using docker stack deploy
# This role uses stored docker-compose files from previous deployments
#
# Phases:
# 1. Discovery - Find available releases and sort by timestamp
# 2. Validation - Check if rollback is possible
# 3. Execution - Deploy previous release
# 4. Cleanup - Remove failed release and its images

# ============================================
# PHASE 1: DISCOVERY
# ============================================

- name: Display rollback initiation message
  debug:
    msg: |
      INITIATING ROLLBACK
      External health checks failed - rolling back to previous release

- name: Find available releases for rollback
  find:
    paths: "{{ stack_dir }}"
    file_type: directory
    excludes: "current"
  register: available_releases

- name: Read metadata from all releases to get timestamps
  slurp:
    src: "{{ item.path }}/metadata.json"
  register: all_metadata
  loop: "{{ available_releases.files }}"
  failed_when: false
  loop_control:
    label: "{{ item.path | basename }}"

- name: Sort releases by timestamp (newest first)
  set_fact:
    sorted_releases: >-
      {%- set releases_with_timestamp = [] -%}
      {%- for result in all_metadata.results -%}
        {%- if result.content is defined -%}
          {%- set metadata = result.content | b64decode | from_json -%}
          {%- set _ = releases_with_timestamp.append({
            'path': result.item.path,
            'version': metadata.version | default(result.item.path | basename),
            'timestamp': metadata.timestamp | default('1970-01-01T00:00:00Z')
          }) -%}
        {%- else -%}
          {%- set _ = releases_with_timestamp.append({
            'path': result.item.path,
            'version': result.item.path | basename,
            'timestamp': '1970-01-01T00:00:00Z'
          }) -%}
        {%- endif -%}
      {%- endfor -%}
      {{ releases_with_timestamp | sort(attribute='timestamp', reverse=true) }}
  when: available_releases.files | length > 0

# ============================================
# PHASE 2: VALIDATION
# ============================================

- name: Determine current and previous release
  set_fact:
    current_release: "{{ sorted_releases[0] if sorted_releases | length > 0 else {} }}"
    previous_release: "{{ sorted_releases[1] if sorted_releases | length > 1 else {} }}"
  when: sorted_releases is defined

- name: Check if rollback is possible
  set_fact:
    can_rollback: "{{ previous_release is defined and previous_release.path is defined }}"

- name: Display no rollback possible message
  debug:
    msg: |
      ROLLBACK NOT POSSIBLE
      No previous release found to rollback to.
      This is likely the first deployment.
      
      Current release: {{ current_release.path | default('none') | basename }}
      Previous releases available: {{ (sorted_releases | length - 1) if sorted_releases is defined else 0 }}
      
      Manual intervention required to deploy a working version.
  when: not (can_rollback | default(false))

- name: Read previous release metadata
  slurp:
    src: "{{ previous_release.path }}/metadata.json"
  register: previous_metadata
  when: can_rollback | default(false)
  failed_when: false

- name: Display rollback target information
  debug:
    msg: |
      Rollback target found:
      - Release: {{ previous_release.path | basename }}
      {% if previous_metadata.content is defined %}
      - Version: {{ (previous_metadata.content | b64decode | from_json).version | default('unknown') }}
      - Timestamp: {{ (previous_metadata.content | b64decode | from_json).timestamp | default('unknown') }}
      {% endif %}
  when: can_rollback | default(false)

# ============================================
# PHASE 3: EXECUTION
# ============================================

- name: Perform rollback using docker stack deploy
  block:
    - name: Update current symlink to previous release
      file:
        src: "{{ previous_release.path }}"
        dest: "{{ stack_dir }}/current"
        state: link
        force: yes

    - name: Deploy previous release version
      shell: |
        cd {{ previous_release.path }}
        
        # Deploy the stack with the previous compose file
        docker stack deploy \
          --compose-file docker-compose.yml \
          {% if config.swarm.prune_services | default(true) | bool %}--prune \{% endif %}
          {% if config.registry.enabled | default(false) | bool %}--with-registry-auth \{% endif %}
          {% if not (config.registry.enabled | default(false) | bool) %}--resolve-image=never \{% endif %}
          {{ stack_name }}
        
        echo "Stack {{ stack_name }} rolled back to version {{ previous_release.version }}"
      register: rollback_deploy
      changed_when: true

    - name: Wait for rollback services to converge
      include_role:
        name: _shared/wait-convergence
      vars:
        convergence_stack_name: "{{ stack_name }}"
        convergence_timeout: "{{ config.swarm.wait_timeout | default(dockflow_defaults.convergence_timeout) }}"
        convergence_context: "rollback"

    # ============================================
    # PHASE 4: CLEANUP
    # ============================================

    - name: Read failed release docker-compose to extract images
      slurp:
        src: "{{ current_release.path }}/docker-compose.yml"
      register: failed_compose
      when:
        - config.stack_management.cleanup_on_failure | default(true) | bool
        - current_release is defined
        - current_release.path is defined
      failed_when: false

    - name: Extract and remove images from failed release
      block:
        - name: Extract image names from failed release
          set_fact:
            failed_images: >-
              {%- set images = [] -%}
              {%- if failed_compose.content is defined -%}
                {%- set compose = failed_compose.content | b64decode | from_yaml -%}
                {%- for svc_name, svc_config in compose.services.items() -%}
                  {%- if svc_config.image is defined -%}
                    {%- set _ = images.append(svc_config.image) -%}
                  {%- endif -%}
                {%- endfor -%}
              {%- endif -%}
              {{ images | unique }}

        - name: Remove images from failed deployment
          shell: "docker rmi {{ item }} 2>/dev/null || true"
          loop: "{{ failed_images | default([]) }}"
          failed_when: false
          loop_control:
            label: "Removing {{ item }}"
          when: failed_images | default([]) | length > 0

      when:
        - config.stack_management.cleanup_on_failure | default(true) | bool
        - failed_compose.content is defined

    - name: Remove failed release directory
      file:
        path: "{{ current_release.path }}"
        state: absent
      when: 
        - current_release is defined
        - current_release.path is defined
        - current_release.path != previous_release.path

    - name: Display rollback success
      debug:
        msg: |
          ROLLBACK COMPLETED
          Successfully rolled back to previous release.
          - Previous version restored from: {{ previous_release.path | basename }}
          - Failed release removed: {{ current_release.path | basename }}

  when: can_rollback | default(false)

- name: Fail deployment after rollback
  fail:
    msg: |
      Deployment failed and was rolled back.
      The previous version is now running.
      
      Check the application logs for details on why the new deployment failed.
  when: can_rollback | default(false)

- name: Fail deployment (no rollback available)
  fail:
    msg: |
      Deployment failed - NO ROLLBACK AVAILABLE
      Health checks did not pass
      No previous healthy version exists for rollback
      
      The failed deployment has been stopped and removed.
      Manual deployment of a working version is required.
  when: not (can_rollback | default(false))
