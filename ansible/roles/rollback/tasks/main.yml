---
# Rollback role - rolls back to a previous release using docker stack deploy
# This role uses stored docker-compose files from previous deployments

- name: Display rollback initiation message
  debug:
    msg: |
      INITIATING ROLLBACK
      External health checks failed - rolling back to previous release

- name: Set stacks directory
  set_fact:
    stacks_dir: "/var/lib/dockflow/stacks/{{ stack_name }}"

- name: Find available releases for rollback
  find:
    paths: "{{ stacks_dir }}"
    file_type: directory
    patterns: "[0-9]*"
  register: available_releases

- name: Sort releases by version (newest first)
  set_fact:
    sorted_releases: >-
      {%- set releases_with_version = [] -%}
      {%- for release in available_releases.files -%}
        {%- set ver = release.path | basename | int -%}
        {%- set _ = releases_with_version.append({'path': release.path, 'version': ver}) -%}
      {%- endfor -%}
      {{ releases_with_version | sort(attribute='version', reverse=true) }}
  when: available_releases.files | length > 0

- name: Determine current and previous release
  set_fact:
    current_release: "{{ sorted_releases[0] if sorted_releases | length > 0 else {} }}"
    previous_release: "{{ sorted_releases[1] if sorted_releases | length > 1 else {} }}"
  when: sorted_releases is defined

- name: Check if rollback is possible
  set_fact:
    can_rollback: "{{ previous_release is defined and previous_release.path is defined }}"

- name: Display no rollback possible message
  debug:
    msg: |
      ROLLBACK NOT POSSIBLE
      No previous release found to rollback to.
      This is likely the first deployment.
      
      Current release: {{ current_release.path | default('none') | basename }}
      Previous releases available: {{ (sorted_releases | length - 1) if sorted_releases is defined else 0 }}
      
      Manual intervention required to deploy a working version.
  when: not (can_rollback | default(false))

- name: Read previous release metadata
  slurp:
    src: "{{ previous_release.path }}/metadata.json"
  register: previous_metadata
  when: can_rollback | default(false)
  failed_when: false

- name: Display rollback target information
  debug:
    msg: |
      Rollback target found:
      - Release: {{ previous_release.path | basename }}
      {% if previous_metadata.content is defined %}
      - Version: {{ (previous_metadata.content | b64decode | from_json).version | default('unknown') }}
      - Timestamp: {{ (previous_metadata.content | b64decode | from_json).timestamp | default('unknown') }}
      {% endif %}
  when: can_rollback | default(false)

- name: Perform rollback using docker stack deploy
  block:
    - name: Update current symlink to previous release
      file:
        src: "{{ previous_release.path }}"
        dest: "{{ stacks_dir }}/current"
        state: link
        force: yes

    - name: Deploy previous release version
      shell: |
        cd {{ previous_release.path }}
        
        # Export environment variables from .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi
        
        # Deploy the stack with the previous compose file
        docker stack deploy \
          --compose-file docker-compose.yml \
          {% if deployment_config.swarm.prune_services | default(true) | bool %}--prune \{% endif %}
          {% if deployment_config.registry.enabled | default(false) | bool %}--with-registry-auth \{% endif %}
          {% if not (deployment_config.registry.enabled | default(false) | bool) %}--resolve-image=never \{% endif %}
          {{ stack_name }}
        
        echo "Stack {{ stack_name }} rolled back to {{ previous_release.path | basename }}"
      register: rollback_deploy
      changed_when: true

    - name: Wait for rollback services to converge
      shell: |
        TIMEOUT={{ deployment_config.swarm.wait_timeout | default(120) }}
        ELAPSED=0
        INTERVAL=5
        
        echo "Waiting for rollback services to converge..."
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          SERVICES=$(docker stack services {{ stack_name }} --format "{{ '{{' }}.Name{{ '}}' }}:{{ '{{' }}.Replicas{{ '}}' }}")
          
          ALL_RUNNING=true
          for SERVICE in $SERVICES; do
            NAME=$(echo $SERVICE | cut -d: -f1)
            REPLICAS=$(echo $SERVICE | cut -d: -f2)
            CURRENT=$(echo $REPLICAS | cut -d/ -f1)
            DESIRED=$(echo $REPLICAS | cut -d/ -f2)
            
            if [ "$CURRENT" != "$DESIRED" ]; then
              ALL_RUNNING=false
            fi
          done
          
          if [ "$ALL_RUNNING" = "true" ]; then
            echo "Rollback services converged successfully"
            exit 0
          fi
          
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
        done
        
        echo "Warning: Rollback timeout reached"
        exit 1
      register: rollback_wait
      failed_when: false
      changed_when: false

    - name: Read failed release docker-compose to extract images
      slurp:
        src: "{{ current_release.path }}/docker-compose.yml"
      register: failed_compose
      when:
        - deployment_config.stack_management.cleanup_on_failure | default(true) | bool
        - current_release is defined
        - current_release.path is defined
      failed_when: false

    - name: Extract and remove images from failed release
      block:
        - name: Extract image names from failed release
          set_fact:
            failed_images: >-
              {%- set images = [] -%}
              {%- if failed_compose.content is defined -%}
                {%- set compose = failed_compose.content | b64decode | from_yaml -%}
                {%- for svc_name, svc_config in compose.services.items() -%}
                  {%- if svc_config.image is defined -%}
                    {%- set _ = images.append(svc_config.image) -%}
                  {%- endif -%}
                {%- endfor -%}
              {%- endif -%}
              {{ images | unique }}

        - name: Remove images from failed deployment
          shell: "docker rmi {{ item }} 2>/dev/null || true"
          loop: "{{ failed_images | default([]) }}"
          failed_when: false
          loop_control:
            label: "Removing {{ item }}"
          when: failed_images | default([]) | length > 0

      when:
        - deployment_config.stack_management.cleanup_on_failure | default(true) | bool
        - failed_compose.content is defined

    - name: Remove failed release directory
      file:
        path: "{{ current_release.path }}"
        state: absent
      when: 
        - current_release is defined
        - current_release.path is defined
        - current_release.path != previous_release.path

    - name: Display rollback success
      debug:
        msg: |
          ROLLBACK COMPLETED
          Successfully rolled back to previous release.
          - Previous version restored from: {{ previous_release.path | basename }}
          - Failed release removed: {{ current_release.path | basename }}

  when: can_rollback | default(false)

- name: Fail deployment after rollback
  fail:
    msg: |
      Deployment failed and was rolled back.
      The previous version is now running.
      
      Check the application logs for details on why the new deployment failed.
  when: can_rollback | default(false)

- name: Display rollback failure message
  debug:
    msg: |
      ⚠️  No rollback scripts found
      Previous deployment state cannot be restored automatically
      This may happen if:
      - This is the first deployment
      - Rollback scripts were manually deleted
      - Previous deployment did not complete successfully
  when: 
    - can_rollback | default(false)
    - (rollback_files_filtered is not defined or rollback_files_filtered | length == 0)

- name: Fail deployment after rollback (with previous version restored)
  fail:
    msg: |
      Deployment failed and has been rolled back
      Health checks did not pass
      Previous deployment state has been restored
  when: 
    - can_rollback | default(false)
    - rollback_files_filtered is defined
    - rollback_files_filtered | length > 0

- name: Fail deployment after cleanup (no rollback available)
  fail:
    msg: |
      Deployment failed - NO ROLLBACK AVAILABLE
      Health checks did not pass
      No previous healthy version exists for rollback
      
      The failed deployment has been stopped and removed.
      Manual deployment of a working version is required.
  when: not (can_rollback | default(false))
