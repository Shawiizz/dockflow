---
- name: Set temporary build directory path
  set_fact:
    tmp_build_dir: "/tmp/docker-build-{{ project_name }}-{{ env }}-{{ version }}"

- name: Ensure Git is installed on remote server
  apt:
    name: git
    state: present
    update_cache: yes
  become: yes

- name: Create temporary directory for git clone
  file:
    path: "{{ tmp_build_dir }}"
    state: directory
    mode: '0755'

- name: Clean up old temporary build directories
  shell: |
    find /tmp -maxdepth 1 -name 'docker-build-*' -type d -mtime +1 -exec rm -rf {} + || true
  register: cleanup_old_dirs
  changed_when: false
  ignore_errors: yes

- name: Clean up Docker to free space
  shell: docker system prune -af || true
  register: cleanup_result
  changed_when: cleanup_result.stdout is search('deleted') or cleanup_result.stdout is search('freed')

- name: Get all Git information in a single command
  shell: |
    echo "repo_url=$(git config --get remote.origin.url)"
    echo "branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)"
    echo "commit=$(git rev-parse HEAD 2>/dev/null || echo '')"
  args:
    chdir: "{{ root_path or '..' }}"
  delegate_to: localhost
  register: git_info_raw
  changed_when: false
  failed_when: false

- name: Parse Git information
  set_fact:
    repo_url: "{{ git_info_raw.stdout_lines | select('match', '^repo_url=') | first | regex_replace('^repo_url=', '') | trim }}"
    git_ref: "{{ git_info_raw.stdout_lines | select('match', '^branch=') | first | regex_replace('^branch=', '') | trim }}"
    git_sha: "{{ git_info_raw.stdout_lines | select('match', '^commit=') | first | regex_replace('^commit=', '') | trim }}"
    git_token: "{{ lookup('env', 'GIT_TOKEN') | default('', true) }}"
    ci_job_token: "{{ lookup('env', 'CI_JOB_TOKEN') | default('', true) }}"
  no_log: true

- name: Use CI_JOB_TOKEN if no explicit git_token provided (GitLab)
  set_fact:
    effective_git_token: "{{ git_token if git_token else ci_job_token }}"
  no_log: true

- name: Build authenticated Git URL for private repos
  set_fact:
    clone_url: >-
      {%- if effective_git_token -%}
        {%- if 'github.com' in repo_url -%}
          {{ repo_url | regex_replace('^https://github.com/', 'https://x-access-token:' + effective_git_token + '@github.com/') | regex_replace('^git@github.com:', 'https://x-access-token:' + effective_git_token + '@github.com/') }}
        {%- elif 'gitlab.com' in repo_url or 'gitlab' in repo_url -%}
          {{ repo_url | regex_replace('^https://([^/]+)/', 'https://oauth2:' + effective_git_token + '@\\1/') | regex_replace('^git@([^:]+):', 'https://oauth2:' + effective_git_token + '@\\1/') }}
        {%- else -%}
          {{ repo_url }}
        {%- endif -%}
      {%- else -%}
        {{ repo_url }}
      {%- endif -%}
  no_log: true

- name: Clone repository to remote server
  shell: |
    rm -rf {{ tmp_build_dir }}
    git clone --branch {{ git_ref }} --single-branch {{ clone_url }} {{ tmp_build_dir }}
    {% if git_sha %}
    cd {{ tmp_build_dir }}
    git checkout {{ git_sha }}
    {% endif %}
  environment:
    GIT_TERMINAL_PROMPT: "0"
  register: git_clone_result
  no_log: true

- name: Fail if git clone failed
  fail:
    msg: "Failed to clone repository. Check if GIT_TOKEN is set for private repos or if the server has access to the repository."
  when: git_clone_result.rc is defined and git_clone_result.rc != 0

- name: Copy rendered docker directory to remote server
  copy:
    src: "{{ root_path | default('..') }}/.deployment/docker/"
    dest: "{{ tmp_build_dir }}/.deployment/docker/"
    mode: '0755'

- name: Generate build commands using decomposerize
  shell: |
    cd {{ root_path or '..' }}/.deployment/docker
    decomposerize docker-compose.yml --docker-build {{ services_option }} {{ environmentize_option }} --ansible-env-vars-format > /tmp/decomposerize_build.j2
  delegate_to: localhost
  changed_when: false

- name: Render template with evaluated variables
  template:
    src: /tmp/decomposerize_build.j2
    dest: /tmp/decomposerize_build_rendered.sh
  delegate_to: localhost
  changed_when: false

- name: Get rendered commands
  slurp:
    src: /tmp/decomposerize_build_rendered.sh
  delegate_to: localhost
  register: rendered_build_script
  changed_when: false

- name: Set evaluated build commands
  set_fact:
    build_commands: >-
      {{
        rendered_build_script.content
        | b64decode
        | split('\n')
        | map('trim')
        | select('truthy')
        | list
      }}

- name: Build Docker images on remote server (parallel)
  shell: |
    cd {{ tmp_build_dir }}/.deployment/docker
    set -e
    PIDS=""
    {% for cmd in build_commands %}
    echo "Starting build: {{ cmd | regex_replace('.*-t\\s+\"?([^\"\\s]+)\"?.*', '\\1') }}"
    ( {{ cmd }} 2>&1 ) &
    PIDS="$PIDS $!"
    {% endfor %}
    # Wait for all builds and capture exit codes
    FAILED=0
    for PID in $PIDS; do
      if ! wait $PID; then
        FAILED=1
      fi
    done
    exit $FAILED
  when: build_commands is defined and build_commands | length > 0
  async: 3600  # Allow up to 1 hour for all builds
  poll: 10
  register: build_results
  ignore_errors: yes

- name: Display build output
  debug:
    msg: "{{ build_results.stdout_lines | default([]) }}"
  when:
    - build_results.stdout_lines is defined
    - build_results.stdout_lines | length > 0

- name: Show build failure
  debug:
    msg: |
      Docker builds failed!
      Return code: {{ build_results.rc }}
      
      STDOUT:
      {{ build_results.stdout | default('No stdout') }}
      
      STDERR:
      {{ build_results.stderr | default('No stderr') }}
  when:
    - build_results.rc is defined
    - build_results.rc != 0

- name: Fail if build failed
  fail:
    msg: "One or more Docker builds failed. Check the output above for details."
  when:
    - build_results.rc is defined
    - build_results.rc != 0

- name: Push images to registry
  include_role:
    name: docker-registry
  vars:
    built_images: "{{ build_commands | select('search', '-t\\s+') | map('regex_replace', '.*-t\\s+\"?([^\"\\s]+)\"?.*', '\\1') | list }}"
  when:
    - deployment_config.registry is defined
    - deployment_config.registry.enabled | default(false) | bool

- name: Cleanup temporary build directory
  file:
    path: "{{ tmp_build_dir }}"
    state: absent
  ignore_errors: yes
