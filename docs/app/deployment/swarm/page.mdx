# Docker Swarm Deployment

This guide explains how Dockflow deploys your applications using Docker Swarm mode.

## Overview

Starting with Dockflow v2.0, **Docker Swarm is the only deployment mode**. Even single-node deployments use Swarm for consistency and reliability.

Docker Swarm provides:
- **Service replication** - Run multiple instances of your services
- **Load balancing** - Automatic load distribution across replicas
- **Rolling updates** - Zero-downtime deployments with automatic rollback
- **Health checks** - Automatic service recovery
- **Resource management** - CPU and memory limits/reservations

## How It Works

### Deployment Flow

1. **Build Phase**: Images are built locally in CI or on the remote server
2. **Transfer Phase**: Images are transferred via local registry tunnel (no external registry needed) or pushed to a configured registry
3. **Deploy Phase**: `docker stack deploy` deploys the stack with automatic rollback configuration
4. **Health Check Phase**: 
   - Swarm monitors internal container healthchecks
   - Dockflow runs external HTTP checks as a second layer of verification
5. **Cleanup Phase**: Old stacks are cleaned up based on retention settings

### Stack Management

Dockflow stores each deployment as a "release":

```
/var/lib/dockflow/stacks/my-app-production/
  1/                         # First release
    docker-compose.yml       # Rendered compose file
    metadata.json            # Deployment metadata with images list
    .env                     # Environment variables
  2/                         # Second release
    docker-compose.yml
    metadata.json
  current -> 2/              # Symlink to active release
```

This enables:
- Quick rollback to any previous release
- Audit trail of deployments
- Automatic cleanup of old releases and their images

## Configuration

### 1. Set Project Name (Required)

In your `.deployment/config.yml`:

```yaml
project_name: "my-app"  # Required: lowercase, alphanumeric, hyphens only
```

### 2. Configure Registry (Optional)

For multi-node clusters or faster deployments, configure a registry:

```yaml
registry:
  enabled: true
  url: "registry.example.com"
  namespace: "myorganization"
  auth_method: "basic"
  username: "{{ registry_username }}"
  password: "{{ registry_password }}"
```

**Note:** If no registry is configured, Dockflow uses an SSH tunnel with a local registry for image transfer. This works for single-node deployments.

### 3. Configure Swarm Settings

```yaml
swarm:
  prune_services: true      # Remove old services (default: true)
  wait_for_services: true   # Wait for services to converge (default: true)
  wait_timeout: 300         # Timeout in seconds (default: 300)
  healthcheck_timeout: 120  # Timeout for internal healthchecks (default: 120)
```

### 4. Configure Stack Retention

```yaml
stack_management:
  keep_releases: 3           # Number of previous releases to keep (default: 3)
  cleanup_on_failure: true   # Clean up failed deployment images (default: true)
```

## Docker Compose Configuration

### Adding Deploy Section

In your `.deployment/docker/docker-compose.yml`, add a `deploy` section to configure Swarm behavior. Dockflow will automatically inject safe defaults if not specified:

```yaml
services:
  app:
    image: my-app
    build:
      context: ../..
      dockerfile: Dockerfile.app
    environment:
      ENV: ${ENV}
    ports:
      - "${APP_EXTERNAL_PORT}:3000"
    deploy:
      replicas: 2
      update_config:
        parallelism: 1
        delay: 10s
        order: stop-first
        failure_action: rollback  # Automatic rollback on failure
        monitor: 30s              # Monitor period after update
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
```

### Default Injection

Dockflow automatically injects safe deployment defaults for all services:

```yaml
deploy:
  update_config:
    parallelism: 1
    delay: 10s
    failure_action: rollback
    monitor: 30s
    max_failure_ratio: 0
```

This ensures automatic rollback if any container fails its healthcheck.

## Health Checks

Dockflow provides two layers of health checks for maximum reliability:

### 1. Internal Health Checks (Swarm)

Docker Swarm monitors container healthchecks defined in your Dockerfile or docker-compose.yml:

```yaml
services:
  app:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3
```

If a container fails its healthcheck during deployment, Swarm automatically rolls back to the previous version.

### 2. External Health Checks (Dockflow)

After Swarm healthchecks pass, Dockflow performs HTTP checks from outside the container:

```yaml
health_checks:
  enabled: true
  startup_delay: 15
  on_failure: "rollback"
  
  endpoints:
    - name: "API Health"
      url: "http://localhost:3000/health"
      expected_status: 200
      timeout: 30
      retries: 3
```

This double-layer approach ensures services are truly accessible, not just running.

## Rollback

### Automatic Rollback (Swarm)

If internal healthchecks fail during deployment, Swarm automatically rolls back. This is handled by:

```yaml
deploy:
  update_config:
    failure_action: rollback
```

### Automatic Rollback (Dockflow)

If external healthchecks fail, Dockflow triggers a rollback using the previous stack release:

```yaml
health_checks:
  on_failure: "rollback"
```

### Manual Rollback

Dockflow stores previous releases. To manually rollback:

```bash
# View available releases
ls /var/lib/dockflow/stacks/my-app-production/

# The previous release can be deployed using:
cd /var/lib/dockflow/stacks/my-app-production/1
docker stack deploy -c docker-compose.yml my-app-production
```

## Deploy Section Options

### Replicas

```yaml
deploy:
  replicas: 3  # Number of task instances
```

### Update Configuration

```yaml
deploy:
  update_config:
    parallelism: 2          # Number of containers to update at a time
    delay: 10s              # Delay between updates
    order: stop-first       # or "start-first"
    failure_action: rollback # "pause", "continue", or "rollback"
    monitor: 30s            # Time to monitor for failure
    max_failure_ratio: 0.2  # Acceptable failure rate
```

### Restart Policy

```yaml
deploy:
  restart_policy:
    condition: on-failure   # "none", "on-failure", or "any"
    delay: 5s
    max_attempts: 3
    window: 120s
```

### Resource Constraints

```yaml
deploy:
  resources:
    limits:
      cpus: '0.5'          # Maximum CPU
      memory: 512M         # Maximum memory
    reservations:
      cpus: '0.25'         # Minimum CPU guarantee
      memory: 256M         # Minimum memory guarantee
```

### Placement Constraints

```yaml
deploy:
  placement:
    constraints:
      - node.role == worker
      - node.labels.type == production
    preferences:
      - spread: node.labels.zone
```

### Labels

```yaml
deploy:
  labels:
    com.example.description: "My application"
    com.example.version: "1.0"
```

## Deployment Workflow

### Standard Deployment

```bash
# Build and push images, then deploy to Swarm
dockflow deploy production
```

### Remote Build

If you want to build images on the remote server:

```yaml
# In config.yml
options:
  remote_build: true
```

Then deploy:

```bash
dockflow deploy production
```

## Monitoring Deployment

After deployment, you can check the status:

```bash
# List services in the stack
docker stack services my-stack-name

# List tasks (containers) in the stack
docker stack ps my-stack-name

# View service logs
docker service logs my-stack-name_app
```

## Scaling Services

To scale a service after deployment:

```bash
docker service scale my-stack-name_app=5
```

Or update your `docker-compose.yml` and redeploy:

```yaml
deploy:
  replicas: 5
```

## Rolling Updates

Swarm automatically performs rolling updates when you:
- Push a new image version
- Change service configuration
- Update environment variables

To trigger a rolling update:

```bash
dockflow deploy production
```

## Rollback

To rollback to the previous version:

```bash
docker service rollback my-stack-name_app
```

## Multi-Host Swarm

For a multi-node Swarm cluster:

1. **Initialize Swarm on the manager node** (done automatically by Dockflow)
2. **Join worker nodes**:
   ```bash
   # On manager, get the join token
   docker swarm join-token worker
   
   # On each worker node, run the provided command
   docker swarm join --token SWMTKN-... manager-ip:2377
   ```

3. **Deploy your stack** - Dockflow will deploy to the entire cluster

## Troubleshooting

### Services not starting

Check service logs:
```bash
docker service logs my-stack-name_app
```

Check service events:
```bash
docker service ps my-stack-name_app --no-trunc
```

### Image pull errors

Ensure:
- Registry credentials are correct in `config.yml`
- Images were successfully pushed to the registry
- Registry is accessible from the remote server

Check registry login:
```bash
docker login registry.example.com -u username
```

### Update failures

If updates fail, Swarm will automatically rollback if `failure_action: rollback` is set.

Check update status:
```bash
docker service inspect my-stack-name_app --pretty
```

## Best Practices

1. **Always use a registry** - Swarm requires images in a registry for multi-node deployments
2. **Set resource limits** - Prevent services from consuming all resources
3. **Use health checks** - Enable automatic recovery of failed containers
4. **Configure update strategy** - Control rolling update behavior
5. **Test in staging** - Verify Swarm configuration before production
6. **Monitor resources** - Use Portainer or other tools to monitor the cluster

## Differences from Standard Deployment

| Aspect | Standard Docker | Docker Swarm |
|--------|----------------|--------------|
| Orchestration | Manual | Automatic |
| Scaling | Manual `docker-compose up --scale` | Automatic via replicas |
| Load Balancing | External (nginx) | Built-in |
| Rolling Updates | Manual | Automatic |
| Health Recovery | Via restart policy | Automatic rescheduling |
| Registry Requirement | Optional | Required for multi-node |

## Example: Complete Configuration

### config.yml
```yaml
project_name: "my-app"

options:
  environmentize: true
  remote_build: false

registry:
  enabled: true
  url: "ghcr.io"
  namespace: "myorg"
  auth_method: "token"
  token: "{{ github_token }}"

swarm:
  stack_name: "{{ project_name }}-{{ env }}"
  prune_services: true
  wait_for_services: true
  wait_timeout: 300
```

### docker-compose.yml
```yaml
services:
  web:
    image: my-web-app
    build: .
    ports:
      - "80:80"
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: stop-first
        failure_action: rollback
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
      placement:
        constraints:
          - node.role == worker
```

## See Also

- [Docker Registry Configuration](/configuration/registry)
- [Health Checks](/configuration/health-checks)
- [Multi-Host Deployment](/configuration/multi-host)
- [Docker Swarm Documentation](https://docs.docker.com/engine/swarm/)
